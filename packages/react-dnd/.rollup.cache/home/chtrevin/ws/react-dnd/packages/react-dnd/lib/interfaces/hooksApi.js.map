{"version":3,"file":"hooksApi.js","sourceRoot":"","sources":["../../src/interfaces/hooksApi.ts"],"names":[],"mappings":"","sourcesContent":["import { TargetType, SourceType } from 'dnd-core'\nimport { DropTargetMonitor, DragSourceMonitor } from './monitors'\nimport { DragSourceOptions, DragPreviewOptions } from './options'\n\nexport interface DragSourceHookSpec<\n\tDragObject extends DragObjectWithType,\n\tDropResult,\n\tCollectedProps\n> {\n\t/**\n\t * A plain javascript item describing the data being dragged.\n\t * This is the only information available to the drop targets about the drag\n\t * source so it's important to pick the minimal data they need to know.\n\t *\n\t * You may be tempted to put a reference to the component or complex object here,\n\t * but you shouldx try very hard to avoid doing this because it couples the\n\t * drag sources and drop targets. It's a good idea to use something like\n\t * { id: props.id }\n\t *\n\t */\n\titem: DragObject\n\n\t/**\n\t * The drag source options\n\t */\n\toptions?: DragSourceOptions\n\n\t/**\n\t * DragPreview options\n\t */\n\tpreviewOptions?: DragPreviewOptions\n\n\t/**\n\t * When the dragging starts, beginDrag is called. If an object is returned from this function it will overide the default dragItem\n\t */\n\tbegin?: (monitor: DragSourceMonitor) => DragObject | undefined | void\n\n\t/**\n\t * Optional.\n\t * When the dragging stops, endDrag is called. For every beginDrag call, a corresponding endDrag call is guaranteed.\n\t * You may call monitor.didDrop() to check whether or not the drop was handled by a compatible drop target. If it was handled,\n\t * and the drop target specified a drop result by returning a plain object from its drop() method, it will be available as\n\t * monitor.getDropResult(). This method is a good place to fire a Flux action. Note: If the component is unmounted while dragging,\n\t * component parameter is set to be null.\n\t */\n\tend?: (\n\t\tdraggedItem: DragObject | undefined,\n\t\tmonitor: DragSourceMonitor,\n\t) => void\n\n\t/**\n\t * Optional.\n\t * Use it to specify whether the dragging is currently allowed. If you want to always allow it, just omit this method.\n\t * Specifying it is handy if you'd like to disable dragging based on some predicate over props. Note: You may not call\n\t * monitor.canDrag() inside this method.\n\t */\n\tcanDrag?: boolean | ((monitor: DragSourceMonitor) => boolean)\n\n\t/**\n\t * Optional.\n\t * By default, only the drag source that initiated the drag operation is considered to be dragging. You can\n\t * override this behavior by defining a custom isDragging method. It might return something like props.id === monitor.getItem().id.\n\t * Do this if the original component may be unmounted during the dragging and later “resurrected” with a different parent.\n\t * For example, when moving a card across the lists in a Kanban board, you want it to retain the dragged appearance—even though\n\t * technically, the component gets unmounted and a different one gets mounted every time you move it to another list.\n\t *\n\t * Note: You may not call monitor.isDragging() inside this method.\n\t */\n\tisDragging?: (monitor: DragSourceMonitor) => boolean\n\n\t/**\n\t * A function to collect rendering properties\n\t */\n\tcollect?: (monitor: DragSourceMonitor) => CollectedProps\n}\n\n/**\n * Interface for the DropTarget specification object\n */\nexport interface DropTargetHookSpec<DragObject, DropResult, CollectedProps> {\n\t/**\n\t * The kinds of dragItems this dropTarget accepts\n\t */\n\taccept: TargetType\n\n\t/**\n\t * The drop target options\n\t */\n\toptions?: any\n\n\t/**\n\t * Optional.\n\t * Called when a compatible item is dropped on the target. You may either return undefined, or a plain object.\n\t * If you return an object, it is going to become the drop result and will be available to the drag source in its\n\t * endDrag method as monitor.getDropResult(). This is useful in case you want to perform different actions\n\t * depending on which target received the drop. If you have nested drop targets, you can test whether a nested\n\t * target has already handled drop by checking monitor.didDrop() and monitor.getDropResult(). Both this method and\n\t * the source's endDrag method are good places to fire Flux actions. This method will not be called if canDrop()\n\t * is defined and returns false.\n\t */\n\tdrop?: (\n\t\titem: DragObject,\n\t\tmonitor: DropTargetMonitor,\n\t) => DropResult | undefined\n\n\t/**\n\t * Optional.\n\t * Called when an item is hovered over the component. You can check monitor.isOver({ shallow: true }) to test whether\n\t * the hover happens over just the current target, or over a nested one. Unlike drop(), this method will be called even\n\t * if canDrop() is defined and returns false. You can check monitor.canDrop() to test whether this is the case.\n\t */\n\thover?: (item: DragObject, monitor: DropTargetMonitor) => void\n\n\t/**\n\t * Optional. Use it to specify whether the drop target is able to accept the item. If you want to always allow it, just\n\t * omit this method. Specifying it is handy if you'd like to disable dropping based on some predicate over props or\n\t * monitor.getItem(). Note: You may not call monitor.canDrop() inside this method.\n\t */\n\tcanDrop?: (item: DragObject, monitor: DropTargetMonitor) => boolean\n\n\t/**\n\t * A function to collect rendering properties\n\t */\n\tcollect?: (monitor: DropTargetMonitor) => CollectedProps\n}\n\nexport interface DragObjectWithType {\n\ttype: SourceType\n}\n"]}